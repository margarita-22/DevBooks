# [22-05-19] Clean Code 11, 12장

생성일: 2022년 5월 18일 오후 9:51
태그: 스터디

# Clean Code 11, 12장

- 2022-05-19
    - 11장 시스템, 12장 창발성

**책에서 기억하고 싶은 내용을 써보세요.**

- 11장 시스템
    - 시스템 제작과 사용을 분리하라
        - 제작과 사용은 아주 다르다.
        - 소프트웨어 시스템은 준비과정 (애플리케이션 객체를 제외하고 의존성을 서로 연결)과 런타임로직 (준비과정 이후)을 분리해야 한다.
    - 관심사 분리
        - 초기화 지연, 계산 지연
        - 장점
            - 실제로 필요할 때까지 객체를 생성하지 않음 -> 불필요한 부하 X
            - null을 반환하지 않는다.
        - 단점
            - 의존성을 해결하지 않으면 컴파일 할 수 없다.
            - 테스트 시 테스트 전용 객체를 또 할당해야한다.
            - 단일책임원칙을 위배한다.
    - main 분리
        - 시스템 생성과 시스템 사용을 분리하는 한 가지 방법
            - 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모두 객체가 생성되었고 모든 의존성이 연결되었다고 가정
    - 팩토리
        - ABSTRACT FACTORY 패턴을 사용. -> 생성 시점은 애플리케이션이 결정하지만 생성하는 코드는 모른다.
    - 의존성 주입
        - 제어 역전 기법을 의존성 관리에 적용한 매커니즘이다 - 단일책임원칙을 지키게 된다.
        - jndi검색은 의존성 주입을 부분적으로 구현한 기능
        - 대다수 di 컨테이너는 필요할때까지는 객체를 생성하지 않고, 대부분은 계산 지연이나 비슷한 최적화에 쓸 수 있도록 팩토리를 호출하거나 프록시를 생성하는 방법을 제공한다.
    - 확장
        - 주어진 사용자 스토리에 맞춰 시스템을 구현해야한다.
        - 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.
        - 관심사 분리가 적절하지 못한 예
            - EJB1, EJB2
            1. 클라이언트가 사용 할 (프로세스 내) 지역 인터페이스나 원격 인터페이스를 정의
            2. 영구 저장소에서 객체와 관곟ㅇ 자료가 매핑되는 방식, 원하는 트랜잭션 동작 방식, 보안 제약조건 등 XML 배포 기술자를 작성해야 한다.
    - 횡단 관심사
        - 원론적으로 모듈화되고 캡슐화된 방식으로 영속성 방식을 구상할 수 있다. 하지만 현실적으로 영속성 방식을 구현한 코드가 온갖 객체로 흩어진다. AOP에서 특정 관점(Aspect)라는 모듈 구성 개념은 “특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다”라고 명시한다.
        - 자바 프록시
            - 단순한 상황에 적합하다.
            - 개별 객체나 클래스에서 메서드 호출을 감싸는 경우가 좋은 예
        - 순수 자바 AOP 프레임워크
            - 순수 자바 관점을 구현하는 Spring AOP 등과 같은 여러 자바 프레임워크는 내부적으로 프록시를 사용한다.
            - 애플리케이션은 사실상 스프링과 독립적이다.
        - AspectJ 관점
            - 관심사를 관점으로 분리하는 가장 강력한 도구
    - 테스트 주도 시스템 아키텍처 구축
        - 
    - 의사 결정을 최적화 하라
        - 큰 시스템은 한 사람이 모든 결정을 내리기 어렵다. 때때로 가능한 마지막 순간까지 결정을 미루는 방법이 최선
            - 최대한 정보를 모아 최선의 결정을 내린다.
            - 성급한 결정은 불충분한 지식으로 내린 결정이다.
            - 너무 일찍 결정하면 고객 피드백을 더 모으고 프로젝트를 더 고민하고 구현 방안을 더 탐험할 기회가 사라진다.
    - 명백한 가치가 있을 때 표준을 현명하게 사용하라
        - 여러 형태로 아주 과장되게 포장된 표준에 집착하는 바람에 고객 가치가 뒷전으로 밀려난 사례
    - 시스템은 도메인 특화 언어가 필요하다
        - DSL은 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올린다.
    - 실제로 돌아가는 가장 단순한 수단을 사용해야 한다.
- 12장 창발성
    
    단순한 설계규칙
    
    1. 모든 테스트를 실행한다
    2. 중복을 없앤다.
        1. ‘소규모 재사용’은 시스템 복잡도를 극적으로 줄여준다. 소규모 재사용을 제대로 익혀야 대규모 재사용이 가능하다.
        2. 중복을 제외하고… 하위클래스는 중복되지 않는 정보만 제공해 알고리즘에서 빠진 구멍을 메운다 (221p)
    3. 프로그래머 의도를 표현하라
        1. 좋은 이름을 선택한다.
        2. 함수와 클래스 크기를 가능한 줄인다.
        3. 표준명칭을 사용한다.
            1. 클래스가 command나 visitor같은 표준 패턴을 사용해 구현된다면 클래스 이름에 패턴 이름을 넣어준다.
        4. 단위테스트 케이스를 꼼꼼히 작성한다.
            1. 테스트 케이스는 예제로 보여주는 문서이다.
        - 나중에 코드를 읽을 사람은 바로 자신일 가능성이 높다. 함수와 클래스에 조금 더 시간을 투자하자. 더 나은 이름을 선택하고, 큰 함수를 작은 함수 여럿으로 나누고, 자신의 작품에 조금만 더 주의를 기울이자. 주의는 대단한 재능이다.
    4. 클래스와 메서드 수를 최소로 줄여라
        1. 가능한 수를 줄여라
            1. 클래스와 메서드 크기를 줄이자고 조그만 클래스와 메서드를 수없이 만드는 사례도 없지않다. → 무리
        2. 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데 있다.
            1. 설계규칙 중 가장 우선순위가 낮다.
            2. 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다.
    - 리팩터링 단계에서는 소프트웨어의 설계 품질을 높이는 기법이라면 무엇이든 적용해도 괜찮다. 응집도를 높이고, 결합도를 낮추고, 관심사를 분리하고, 시스템 관심사를 모듈로 나누고, 함수와 클래스 크기를 줄이고, 더 나은 이름을 선택하는 등 다양한 기법을 동원한다.
    - 

**오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**

11장

- 너무 이해가 되지 않았다… (11장) 관심사 ← 이 개념 자체가 이해가 잘 안됐다.최선의 용어 번역이 아닌 것 같다;; 이미 저렇게 쓰는 것 같지만.. [관심사란 컴퓨터 프로그램 코드에 영향을 미치는 정보의 집합이다] 라고 하는데.. 의미를 알기 전엔 도무지 이해할 수 없는 문맥이었고, 의미를 알고 나서는 한 명 두 명 세 명 대신 일 명 이 명 삼 명.. 이렇게 세는 것 같달까.. 그냥 안맞는 옷 끼워넣어준 느낌..
- 내가 글을 읽은 것이 아니고 글이 나를 읽은 느낌이었다. 모든 개념들이 다 낯선데 휙휙 바뀌면서 또 다른 설명을 하는 것처럼 느껴져서 다시 봐도 잘 모르겠고… 책을 다 읽고 다시 보면 좀 이해가 될까 싶었다.
- 많은 개념을을 이건 또 무슨말이야.. 하고 찾아보곤 했는데 다 디자인패턴, 모르는 API, 또는 많이 들어보았지만 정확히 뜻은 모르는 (하지만 알아야했던 ;;) 그런 개념들로 설명한 잘 모르는 개념 설명 때문에 혼란 그자체가 아니었나 싶다…
- 이 장을 이해하려면 많은 공부가 필요할 것 같다. 이 장을 이해하게 되면 뭔가 많이 발전해있지않을까
- 의사결정을 최적화 하라는 부분에서 결정을 미뤄야 한다. 여기서 최근 프로젝트에서 호출 방식을 결정하던 때가 생각이 났다. 결국 요구사항 대로 하기로 했고, (그때는 그게 맞았다고 생각이 들었다 지금은 더 지나봐야 알 것 같다 기능이 너무 복잡해) 처음 시작을 너무 딱딱하게 해서 문제였지, 구현 방안을 좀 더 고민해볼 수 있었던 기회였다.
- 복잡한거 한가득 설명해놓고 ㅠ..돌아가는 가장 단순한 수단을 사용하라.. 그 뜻이 아니겠지만 힘들게 읽었는데 허무한 기분도 들었다. 여러 설계 방법이 있지만 최대한 단순화해서 나중을 대비하라는 뜻이지

---

12장

- 설계규칙 1 - TDD를 정말 중요하게 생각 하는구나 - 그렇게 생각 해야 하는구나, 처음은 어려워도 적응되면 개발 + 추후 관리 및 추가가 덜 부담스러울 것 같았다.
- 결합도가 높아 더 어려웠던 거라는 어림짐작이 들었고 정말 하지 말라는 건 다 하는 소스 = 내 소스. 공부를 안했던 게으른 나에 대한 창피함과… 반성과..
- 나중에 읽을 사람을 위해 (아마 내가 될거니까) 보기 편하고 이해하기 효율적인 코드를 짜고, 시스템 적으로도 더 좋은 코드를 짜는 것이 좋다~ 주제에 따라 조금씩 바뀌긴 하지만 내용이 계속 반복되는 것 같긴 하다.
- 창발성이라는 단어를 몰라서 한자를 보고 대강 창의적 발상인가 싶었다. 복잡한 구조에서 상호작용하도록 작성해야하는데 말로 하면 복잡해보이지만 알고보면 저 4가지 규칙만 따르면 된다는 그런 의미인가? 장의 제목과 내용을 연관시키기는 조금 어려웠다.

**궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**

- 팩토리
    - ABSTRACT FACTORY : 실제 팩토리 클래스의 공통 인터페이스 [https://gmlwjd9405.github.io/2018/08/08/abstract-factory-pattern.html](https://gmlwjd9405.github.io/2018/08/08/abstract-factory-pattern.html)
- EJB1, EJB2, EJB3
    - EJB(Enterprise JavaBeans) Enterprise Bean라는 서버 측 컴포넌트를 사용하여 분산 Java EE 애플리케이션을 개발하기 위한 표준 API
    - EJB는 분산, 트랜잭션, 보안 등의 서비스를 제공하는 서버 사이드 컴포넌트이다. EJB 표준은 개발 순서가 복잡하여 불편한 점이 많았지만, EJB 3. 0에서는 배포 디스크립터 대신 어노테이션을 이용할 수 있게 되어 개발이 쉬워지게 되었다. 그리고 EJB 3.1에서는 로컬 세션 빈에 대해서는 인터페이스도 필요하지 않고, WAR 아카이브에 EJB를 포함할 수가 있어 개발자에게 사용하기 쉬운 표준으로 진화하고 있다
- 프록시
    - 실제 작업을 행하는 오브젝트를 감싸서, 실제 오브젝트를 요청하기 전이나 후에 인가 처리(보호)나, 생성 자원이 많이 드는 작업에 대해 백그라운드 처리 (가상), 원격 메소드를 호출하기 위한 작업(원격 프록시) 등을 하는데 사용한다.
- POJO (Plain Old Java Object)
    - 오래된 방식의 간단한 자바 오브젝트
- 테스트 더블 (TEST DOUBLE)
    - 테스트를 진행하기 어려운 경우를 대비해 대신 테스트를 진행해주는 객체
    - [https://tecoble.techcourse.co.kr/post/2020-09-19-what-is-test-double/](https://tecoble.techcourse.co.kr/post/2020-09-19-what-is-test-double/)
- MOCK OBJECT
    - 행위를 테스트한다. (행위를 검증한다)